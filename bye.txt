I have maintained this project for nearly a year.

Creating the Stepper processes on their own was (relatively) easy. Since the process had already been implemented in Python prior to this project, implementing the process in Java was a matter of translating Python to Java.

The first challenge was in making the GUI. I gained experience in Swing with two smaller projects, giving me the necessary experience to implement all necessary GUI components. Looking back, I made the right decision not to directly implement the GUI, instead mastering JComponents, SwingWorkers, and CardLayouts. I felt in total control of the Swing framework upon starting the original Stepper project. 
One quirk about Swing that I discovered during earlier Swing projects is unusual cancelling behavior. My original plan was to have a thread (now the ParsingBoss) deploy worker threads (now ParsingOperationsWorkers and ParsingDiacriticsWorkers). When I tried to cancel the boss thread, the worker threads continued to run. I found that I needed an additional thread (now the ParsingDispatcher) to deploy the boss thread, which in turn deploys the workers. This configuration reliably stopped all worker threads upon cancellation, but required that I pass all inputs to the worker threads into the dispatcher thread, which then created a boss thread around the input, which then created worker threads that used the input.

The hardest part of the project was converting the Stepper operations into a multithreaded process. setWorkerLoads, the function responsible for distributing workloads among threads, was the single hardest function I have ever implemented. Its job is to return an array of Strings, each containing the workload designated for a thread. setWorkerLoads' first working implementation was about 100 lines long and required a helper method. The runtime scaled linearly with the number of characters in the text. I later discovered that the slow runtime of setWorkerLoads was the largest bottleneck in operation runtime. (setWorkerLoads was later optimized) Stepper requires dividing input texts into discrete segments, so to reduce complexity, setWorkerLoads split the text into segments before assigning work to threads. The text division was the source of most of setWorkerLoads' complexity and the reason its optimization didn't arrive for months.
The Stepper algorithm, as its name suggests, has a key with blocks that rotate, or "step", as the process continues. Each segment in the input text uses a different position of the key blocks. The stepping action of the key is easy to implement on a single thread. In a multithreaded operation, each thread needs its own key block position setup depending on the thread text's position in the input. An unexpected challenge, one that I have not yet converted to a multithreaded operation, is configuring the key blocks for each thread. Since the block setup requires knowledge of the entire input, the setup step must be a single-threaded operation.

Version 2 addressed the need to make meaningful use of all blocks in the key. In short texts, some key blocks never rotate, creating many equivalent keys and effectively shrinking the number of possible keys.

I feel that Stepper was the project that turned me into a programmer. It was the single most complicated project I have ever written, requiring six classes and over 5000 lines of code. Stepper was written just before AI tools came into ubiquity, so I manually wrote the entire project. 
I encountered some of the hardest bugs I have seen, especially in the setWorkerLoads method. One test in the SetWorkerLoadsTest file is called "testBugfix", which tests an edge case that remained unnoticed for over a month. Its DisplayName explains the special conditions that caused the bug: "When blockCount divided by minBlockSize, rounded down to the nearest integer, equals 1 and more than 2 blocks should be loaded into each output index, setWorkerLoads should load the appropriate number of blocks (not 1 block) into each output index" (What the DisplayName calls "blocks" are now called "segments"). After solving the bug, I felt extremely confident in my debugging abilities.
As well as finding hard bugs, I optimized functions that I thought were as optimized as possible. A notable optimized function was setWorkerLoads, although I had a tentative solution for months before implementing it. My most proud moment in programming was optimizing setKeyBlockPositions. Although not optimized during the Java Stepper implementation (optimized in the original Python attempt), I still hold the moment as a great victory. The runtime of setKeyBlockPositions scaled linearly with its input value, the length of the input text, requiring one loop iteration per 20 characters. Upon writing the function, I had a feeling that setKeyBlockPositions had lots of untapped potential. Shortly after, I made the function run orders of magnitude faster. I noticed that the setKeyBlockPositions operation converted its input to base-16 (at the time of optimization). The function now ran in time independent of its input with as few as 10 loop iterations. setKeyBlockPositions' constant-time runtime complexity enabled enhanced processes to be implemented later.

Although I hold the Version 2 project dear, I found that maintaining two projects that are identical except for two functions to be too hard. Each change done in one project had to be manually copied to the other project, a process that introduced several bugs and conflicts. I made the decision to merge enhanced process operation with the original Stepper project on June 9, 2025. The simplicity of the merge gave me confidence that combining the projects is the right decision.

If you are reading this message, know that you CANNOT do anything. But know that there is a place where people prize your strengths, overlook your weaknesses, and align you to accomplish the fate that God purpose-built you to do.

Chris Bacon
June 9, 2025; 10:18 PM Central Daylight Time
Fermi National Accelerator Laboratory, Batavia, Illinois